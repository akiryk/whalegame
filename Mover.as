import AsBroadcaster;class Mover {	/*********************	PROPERTIEs	**********************/	private var vel:Vector;	private var pos:Vector;	private var accel:Vector;		private var friction:Number;		private var func:Function; // function that gets called by update		private var mc:MovieClip;		// LISTENER	private var events:Object;		// properties for sine wave function	private var t:Number;	private var amp:Number;	private var period:Number;	private var timeshift:Number;	private var offset:Number;		private var threshold:Vector;		private var splash:Sounds; // sounds is a custom class that works with Flash Sound class		/********************	CONSTRUCTOR FUNCTION	**********************/	public function Mover(posx:Number, posy:Number, velx:Number, vely:Number, accelx:Number, accely:Number, xfriction:Number, yfriction:Number, mc:MovieClip) {		// register with AsBroadcaster		events = new Object();		AsBroadcaster.initialize(events); 				pos = new Vector(posx,posy);		vel = new Vector(velx,vely);		accel = new Vector(accelx, accely);				this.friction = friction;		setUpdateFunction (updateBasic);				this.mc = mc;		this.mc.obj = this;				startEnterFrame();	}		/*******************	BROADCAST/LISTEN FUNCTIONS	********************/	public function addListener(listener:Object){		events.addListener(listener);	}		public function removeListener(listener:Object){		events.removeListener(listener);	}			/****************	SETTER FUNCTIONS	*****************/	public function changePosV(v:Vector):Void{ // updates pos based on a vector object		pos.updateCoords(v.getX(), v.getY());	}		public function changePos(x:Number, y:Number):Void{ // updates pos based on a x, y coords 		pos.updateCoords(x,y);	}		public function changeVelV(v:Vector):Void{ // updates pos based on a vector object		vel.updateCoords(v.getX(), v.getY());	}		public function changeVel(x:Number, y:Number):Void{ // updates pos based on a x, y coords 		vel.updateCoords(x,y);	}		public function changeAccelV(v:Vector):Void{ // updates pos based on a vector object		accel.updateCoords(v.getX(), v.getY());	}		public function changeAccel(x:Number, y:Number):Void{ // updates pos based on a x, y coords 		accel.updateCoords(x,y);	}		public function setThreshold(x:Number, y:Number):Void{ 		this.threshold = new Vector(x, y);	}			// ***********************	// WATER LANDING SETTER	// ************************	public function setWaterLanding():Void {		t = 0;		if ( vel.getY() > 20){			amp = 100;//100;		} else if ( vel.getY() > 14){			amp = Math.ceil(3 * vel.getY()) + 15;//100;		} else {			amp = Math.ceil(3 * vel.getY()) + 10;//100;		}		period = 24;		timeshift = 0;		offset = amp;		setFriction(0.9);	}		/****************	GETTER FUNCTIONS	******************/		public function getVelX():Number {		return vel.getX();	}		public function getPosX():Number {		return pos.getX();	}		public function getVelY():Number {		return vel.getY();	}		public function getPosY():Number {		return pos.getY();	}		public function getThreshold(x:Number, y:Number):Vector{ 		 return this.threshold;	}		//**************************			private function changePosition():Void {				if (vel.getX() == 0){			// do nothing, because _x hasn't changed		} else {			mc._x = pos.getX();		}		if (vel.getY() == 0){			// do nothing, because _y hasn't changed		} else {			mc._y = pos.getY();		}				/*********		broadcast position and velocity so that listener knows place		and direction of mc		*********/		events.broadcastMessage("onChangePos");				if (pos.getX() > threshold.getX()){			events.broadcastMessage("onGoneOffScreen");		}	}		private function startEnterFrame():Void {		this.mc.onEnterFrame = function(){			this.obj.update(); 		}	}		private function stopEnterFrame():Void {		delete this.mc.onEnterFrame; 	}		public function stop():Void {		stopEnterFrame();	}		public function setFriction(f:Number):Void {		this.friction = f;	}				/*********************	UPDATER FUNCTIONS	**********************/		private function update():Void {		this.func();	}		public function setUpdateFunction(f:Function):Void {		func = f;	}		public function setToSinking():Void {		setUpdateFunction(updateSinking);	}		private function updateBasic():Void {		vel.plus(accel);		if (friction != null) vel.updateCoords(applyXFriction(),applyYFriction());		pos.plus(vel);		changePosition();		if (pos.getY() > threshold.getY()){			setWaterLanding();			setUpdateFunction(updateInWater);			addSplashSound();		}	}			private function applyXFriction():Number {		var x = vel.getX();		return  x *= friction;	}		private function applyYFriction():Number {		var y = vel.getY();		return  y *= friction; 	}		public function destroy():Void {		delete events;		delete pos;		delete vel;		delete accel;		stopEnterFrame(); 	}			/*	********	LANDING IN WATER	*******	*/	private function updateInWater():Void {		var newY = getWaterY() + 435; 		// 70 represents the offset needed for smurfy to rise to surface or water		// a higher number would mean smurfy stays underwater		// a lower number means it rises higher up				vel.plus(accel);		applyYFriction();		pos.plus(vel);		pos.updateCoords(pos.getX(), newY);		mc._x = pos.getX();		mc._y = pos.getY();				if (t == Math.ceil(0.75 * period)) {			// surface of water			amp *= .4; // determines how much faller slows down with each re-surfacing			offset =  amp;		}		if (t == Math.ceil(0.25 * period)) { 			period = Math.ceil(period * 0.88);		}		if (t == Math.ceil(period)) {			t = 0;		} else {			t++;		}		if (amp < 4) {			vel.updateCoords(vel.getX(), 2);			accel.updateCoords(accel.getX(), 2);			events.broadcastMessage("onStartSinking");		}	}		// water wave function	private function getWaterY(){ //t, amp, period, timeshift, offset		var y = amp * Math.sin((t - timeshift) * (2 * Math.PI) / period) + offset;		return y;	}		private function addSplashSound():Void {		 // create a new sound object		splash = new Sounds("splash");		splash.setVolume(100);	}		private function killSplashSound():Void {		splash.killSound();		delete splash;	}		/*	********	SINKING IN WATER	*******	*/	private function updateSinking():Void {		vel.plus(accel);		pos.plus(vel);		pos.updateCoords(pos.getX(), pos.getY());		changePosition();		if (pos.getY() > 1000){			events.broadcastMessage("onSunk");		}	}				}