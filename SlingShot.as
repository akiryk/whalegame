import mx.transitions.Tween;import com.robertpenner.easing.*;import util.MathDeluxe;class SlingShot {		// PROPERTIES ****************		// MOVIE CLIPS	private static var slingshot_mc:MovieClip;	private static var pouch_mc:MovieClip;	private static var anchorA_mc:MovieClip;	private static var anchorB_mc:MovieClip;	private static var strings_mc:MovieClip;	private static var dragger_mc:MovieClip;	private var smurfs_mc:MovieClip;		// VECTOR POINTS	private var anchorPtA:Vector; // left anchor point	private var anchorPtB:Vector; // right anchor point	private var pouchCtrPt:Vector; // center point of pouch_mc	private static var centerPoint:Vector; // the center point around which slingshot revolves	private var zeroPoint:Vector; // average between the two anchor points		// TWEEN OBJECTS	private var xTween:Tween;	private var yTween:Tween;		// SMURFY	private var s_array:Array;	private var depth:Number;	private var liveElephant:Elephant; // keeps track of current elephant so when SMurfy changes, new smurfy knows who to register with		// MISC PROPERTIES	private var constantAng:Number; // the angle between the pouch and the right anchor	private var func:Function;	private var boing:Sounds;		// END OF PROPERTIES ***************			// CONSTRUCTOR FUNCTION	public function SlingShot(target:MovieClip){				// set key vectors		centerPoint = new Vector(0, 0);		pouchCtrPt = new Vector(0, 20);		anchorPtA = new Vector(50, 20);		anchorPtB = new Vector(50, 20);		zeroPoint = anchorPtA.getAvg(anchorPtB);				depth = 1;		liveElephant = undefined;				strings_mc = target.createEmptyMovieClip("strings", 1); // clip on which to draw elastic strings		// create main clip on which all smurfies will go		smurfs_mc = target.createEmptyMovieClip("smurfs", 2);		// create main movieclip on which all other slingshot MCs will be placed		slingshot_mc = target.createEmptyMovieClip("sling", 3);				/* attach or create all other slingshot MCs			level 1:	Strings, at the very bottom			level 2: 	anchorA			level 3:	anchorB			level 4:	left open for Smurfy			level 5:	pouch -- needs to be on top of Smurfy so that Smurfy appears to sit inside of it		*/		dragger_mc = slingshot_mc.attachMovie("dragger", "dragger", 7);		pouch_mc = slingshot_mc.attachMovie("pouch", "pouch", 6); // the pouch that holds the ball		anchorA_mc = slingshot_mc.attachMovie("anchor", "anchorA", 3); // left anchor		anchorB_mc = slingshot_mc.attachMovie("anchor", "anchorB", 2); // right anchor				// set anchors in correct start location		anchorA_mc._x = anchorPtA.getX();		anchorA_mc._y = anchorPtA.getY();		anchorB_mc._x = anchorPtB.getX();		anchorB_mc._y = anchorPtB.getY();		pouch_mc._x = dragger_mc._x = pouchCtrPt.getX();		pouch_mc._y = dragger_mc._y = pouchCtrPt.getY();				// set angle of pouch to remain constant with anchors		constantAng = Math.floor(pouchCtrPt.getAngleBetween(anchorPtA));				// Associate MCs with SlingShot object		strings_mc.obj = this;		dragger_mc.obj = this;				s_array = new Array();		makeSmurfy();				turnOnTween();		updateAnchorPoints();				func = updateDragging;		slingshot_mc.obj = this;		resetEnterFrame();	}		private function onSmurfySunk(s:Smurfy):Void { 		for (var i = 0; i < s_array.length; i++) {			if (s == s_array[i]){				s.removeListener(this);				s.killSmurfy();				delete s;			}		}	}		private function onSmurfyInWater():Void {		makeSmurfy();	}		private function makeSmurfy():Void {		// First thing that happens when Smurfy hits the water is to create a new Smurfy in the slingshot		depth+= 2;		var sm:Smurfy = new Smurfy (smurfs_mc, depth, zeroPoint, this); // depth is just below pouch depth		s_array.push(sm);		placeSmurfy(sm);		sm.addListener(this); // now Slingshot can receive messages from the Smurfy -- i.e. when smurfy sinks, sling will hear abou tit 		registerElephant(); // let current elephant know about this smurfy so it can listen for 'pokes'		killBoing();// destroy last boing sound	}		public function setElephant(e:Elephant):Void {		liveElephant = e;		registerElephant();	}		private function registerElephant():Void  {		// get last item in s_array		if (liveElephant != undefined){			var lastItem = getLiveSmurfy(); // returns index in array			s_array[lastItem].addListener(liveElephant); // lets current elephant listen to active smurfy		}	}		public function unregisterElephant(e:Elephant):Void {		// get last item in s_array		var lastItem = getLiveSmurfy(); // returns index in array		s_array[lastItem].removeListener(e);	}		private function getLiveSmurfy():Number {		return Number(s_array.length - 1);	}					/* *****************************************************************	UPDATER FUNCTIONS	updateDragging updates the slingshot when user is dragging pouch	updateReleased updates the slingshot when user has released pouch	********************************************************************/		private function updateDragging():Void { // updater function for when Smurfy is NOT free	 // First, make the vector pouchCtrPt equal the actual x, y coords of the dragger_mc		pouchCtrPt.updateCoords(dragger_mc._x, dragger_mc._y); 	// Then, mouch the pouch_mc exactly to where the dragger_mc is located		pouch_mc._x = dragger_mc._x;//pouchCtrPt.getX();		pouch_mc._y =  dragger_mc._y;//pouchCtrPt.getY();	// Find the liveSmurfy -- the smurfy that is being controlled by user	// ( there may be other smurfees floating or sinking in water that user doesn't control		var lastItem = getLiveSmurfy(); // returns index in array	// Keep live smurfy in pouch, but only if it isn't free		if (s_array[lastItem].getIsFree() == false){			s_array[lastItem].updateCoords(pouchCtrPt); // keep smurfy inside of pouch		}		updateAnchorPoints(); // keep anchor points rotating around center point		updateStrings();	}		private function updateReleased():Void { // updater function for when Smurfy is free		pouchCtrPt.updateCoords(xTween.getPosition(), yTween.getPosition());					// move pouch and dragger to pouch center point vector		pouch_mc._x = dragger_mc._x = pouchCtrPt.getX();		pouch_mc._y =  dragger_mc._y = pouchCtrPt.getY();				// keep smurfy in pouch		var lastItem = getLiveSmurfy(); // returns index in array		if (s_array[lastItem].getIsFree() == false){ // only keep smurfy in pouch if it isn't free			s_array[lastItem].updateCoords(pouchCtrPt); // keep smurfy inside of pouch		}				// keep strings in right place at all times regardless of whether dragged		updateStrings();	}		private function updateStrings():Void {		with (strings_mc) {				// length goes from about 20 to over 700				//var t = 200 / obj.pouchCtrPt.getLength();				clear();				lineStyle(0.25, 0x1C3302, 100);				moveTo(obj.anchorPtA.getX(), obj.anchorPtA.getY());				lineTo(obj.pouchCtrPt.getX(), obj.pouchCtrPt.getY());				moveTo(obj.anchorPtB.getX(), obj.anchorPtB.getY());				lineTo(obj.pouchCtrPt.getX(), obj.pouchCtrPt.getY());			}	}		private function updateAnchorPoints():Void {		// update anchor locations		// anchorPtA is always constantAng less than the angle of pouch center		var ang = pouchCtrPt.getAngle() - constantAng;				var m = new MathDeluxe(); // this lets us perform additional math functions				var x = m.getCosD(ang) * anchorPtA.getLength();		var y = m.getSinD(ang) * anchorPtA.getLength();		anchorPtA.updateCoords(x,y);		anchorA_mc._x = anchorPtA.getX();		anchorA_mc._y = anchorPtA.getY();				// anchorPtB is always constantAng more than the angle of pouch center		ang = pouchCtrPt.getAngle() + constantAng;		x = m.getCosD(ang) * anchorPtA.getLength();		y = m.getSinD(ang) * anchorPtA.getLength();				// get rid of mathDeluxe object		delete m;				anchorPtB.updateCoords(x,y);		anchorB_mc._x = anchorPtB.getX();		anchorB_mc._y = anchorPtB.getY();				var a = pouchCtrPt.getAngle();		dragger_mc._rotation = pouch_mc._rotation = a;		anchorA_mc._rotation = anchorB_mc._rotation = a;	}				public function doDrag():Void {				dragger_mc.dragging = true;		dragger_mc.startDrag(true)		func = updateDragging;		resetEnterFrame();	}		public function endDrag():Void {		/*		THIS IS CALLED BY dragger_mc when dragger has been released within boundaries		First, we stop the drag		Second, we start the release process by turning on tween functions		Third, we release the smurfy		*/		var lastItem = getLiveSmurfy(); // returns index in array		// test whether smurfy is in slingshot or not. If not, simply let the slingshot do its motion		// if smurfy IS is slingshot, set smurfy free AND do slingshot tween		if (s_array[lastItem].getIsFree() == false){			setSmurfyFree();		} else {			func = updateReleased;			resetEnterFrame();		}		turnOffDrag();		turnOnTween();	// tween the slingshot motion		playBoing(); // play "boing" sound	}		private function setSmurfyFree():Void {		delete slingshot_mc.onEnterFrame;		func = updateReleased;		resetEnterFrame();		var lastItem = getLiveSmurfy(); // returns index in array		s_array[lastItem].setFree();		var sound = new Sound(this);		sound.attachSound( "uhhuh" );		sound.start();	}		private function resetEnterFrame():Void {		delete slingshot_mc.onEnterFrame;		slingshot_mc.onEnterFrame = function(){			this.obj.func();		}	}		public function placeSmurfy(s:Smurfy):Void {		s.updateCoords(zeroPoint); // place in center at start/		//func = updateDragging;			}		private function turnOffDrag():Void {		dragger_mc.dragging = false;		dragger_mc.stopDrag();	}		private function turnOnTween():Void {		zeroPoint = anchorPtA.getAvg(anchorPtB);		yTween = new Tween(pouchCtrPt, "pouchCtrPt.x", Elastic.easeOut, pouchCtrPt.getY(), zeroPoint.getY(), 18, false); //obj, prop, func, begin, finish, duration, useSeconds		xTween = new Tween(pouchCtrPt, "pouchCtrPt.y", Elastic.easeOut, pouchCtrPt.getX(), zeroPoint.getX(), 18, false);	}		private function playBoing():Void {		 // create a new sound object		boing = new Sounds("boing");	}		private function killBoing():Void {		boing.killSound();		delete boing;	}	}