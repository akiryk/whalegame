class CollisionManager extends ListOfObjects{	private var updater:MovieClip;	private var grav:Number; // gravity	private var damp:Number; // friction	private var e:Number; // coefficient of restitution		public function CollisionManager(mc) {		super();		this.grav = -.6;		this.damp = .97; 		this.e = 0.9;		updater = mc;		updater.o = this;	}		public function startCheck():Void {		updater.onEnterFrame = function(){			this.o.checkCollisions();		}	}		private function checkCollisions():Void {		var balloon:TiedBalloon;		for (var i:Number = 0; i < objectsToManage.length; i++){			// update velocity; update position; check to see if we are out of bounds			balloon = objectsToManage[i];			balloon.growVel(0,grav) ;			balloon.scaleVel(damp, damp);			balloon.updatePos();			checkWorldCollision(balloon);			balloon.render();		}		for (var i:Number = 0; i<objectsToManage.length-1; i++) {			for (var j:Number =i+1; j<objectsToManage.length; j++) {				checkColl(objectsToManage[i], objectsToManage[j]);			}		}	}			private function checkWorldCollision(bi:Object):Void {		var dx = bi.getPos().x;		var dy = bi.getPos().y;		var dist = Math.sqrt(dx*dx+dy*dy);		var overLap = bi.getOverlap(); // amount by which balloon reaches out of boundaries		if (overLap >= 0) { // COLLISION WITH WORLD BOUNDARIES!			var theta = Math.atan2 (dy, dx); // angle in radians of object from center point			placeOnBoundary(bi, overLap, theta);			adjustToWorld(bi, theta); // change velocity based on world collision		}	}	private function placeOnBoundary(bi:Object, overLap:Number, theta:Number):Void {		// set position to edge of world boundary (it shouldn't be out of bounds)		var dx = -overLap * Math.cos(theta);		var dy = -overLap * Math.sin(theta);		bi.growPos(dx, dy); 	}		private function adjustToWorld(bi:Object,theta:Number):Void {		// reset velocity based on collision with world boundary		// set some convenience variables		var vx = bi.getVel().x;		var vy = bi.getVel().y;		// Rotate world coordinates to get Velocity-prime and Velocity-normal		var vp = ( vx * Math.cos(theta) ) + ( vy * Math.sin(theta)); // Get Velocity prime (vp)		var vn = ( vy * Math.cos(theta)) - ( vx * Math.sin(theta)); // Get velocity normal (vn)		// calculate post collision velocity (vpf = velocity prime final)		var vpf = - (e * vp ); // -e*vp (e = coefficient of restitution, which determines elasticity)		// rotate coordinates back to cartesian to get post-collision velocities		vx = vpf * Math.cos(theta) - vn * Math.sin(theta);		vy = vpf * Math.sin(theta) + vn * Math.cos(theta);		bi.setVel(vx * .9, vy * .9);	}		private function checkColl(b1:Object, b2:Object):Void {		var dx:Number = b2.getPos().x - b1.getPos().x;		var dy:Number = b2.getPos().y - b1.getPos().y;		var dist:Number = Math.sqrt(dx*dx+dy*dy);		// check if distance between the two balls is less than sum of their radii		if (dist < b1.getRadius() + b2.getRadius()) {			var angle:Number = Math.atan2(dy, dx); // angle at which the balloons hit -- the line of action			var cosa:Number = Math.cos(angle);			var sina:Number = Math.sin(angle);			var vx1p:Number = cosa*b1.getVel().x + sina * b1.getVel().y;			var vy1p:Number = cosa*b1.getVel().y - sina*b1.getVel().x;			var vx2p:Number = cosa*b2.getVel().x + sina*b2.getVel().y;			var vy2p:Number = cosa*b2.getVel().y - sina*b2.getVel().x;			// Conservation equations			var P:Number = vx1p*b1.getMass() + vx2p*b2.getMass();			var V:Number = vx1p-vx2p;			vx1p = (P-b2.getMass()*V)/(b1.getMass() + b2.getMass());			vx2p = V+vx1p;			// Project back onto x-y axes			b1.setXvel((cosa*vx1p-sina*vy1p) * 0.9);			b1.setYvel(cosa*vy1p+sina*vx1p);			b2.setXvel((cosa*vx2p-sina*vy2p) * 0.9);			b2.setYvel(cosa*vy2p+sina*vx2p);			//b1.setVel(b1.getVel().x * .9, b1.getVel().y * .9);			//b2.setVel(b1.getVel().x * .9, b1.getVel().y * .9);			var pen:Number = (b1.getRadius() + b2.getRadius())-dist; // total penetration of the two balls			var diff:Number = pen/2; // amount of penetration that each ball must undo.			var cosd:Number = cosa*diff; // diff is our hypotenuse. dx = cos(angle) * hypotenuse			var sind:Number = sina*diff; // this finds our dy			b1.growPos(-cosd, -sind);			b2.growPos(cosd, sind);			b1.render();			b2.render();		}	}		public function removeBalloon(i:Number):Void {		objectsToManage[i].destroy();		delete objectsToManage[i];		objectsToManage.splice(i, 1);		break;	}			}