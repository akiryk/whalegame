class Vector {		/*	* PROPERTIES	*/		public var x:Number;	public var y:Number;		/*	* CONSTRUCTOR FUNCTION	*/	public function Vector(x:Number, y:Number){		this.x = x;		this.y = y;	}		public function updateCoords(x:Number, y:Number){		this.x = x;		this.y = y;	}		public function getX():Number {		return this.x;	}			public function getY():Number {		return this.y;	}		public function getClone ():Vector {		return new Vector(x,y);	}		public function equals (v:Vector):Boolean {		return (this.x == v.x  && this.y == v.y);	}		// ADD and SUBTRACT vectors	public function plus(v:Vector):Void {		this.x += v.x;		this.y += v.y;	}		public function plusNew(v:Vector):Vector {		return new Vector(this.x + v.x, this.y + v.y);	}		public function minus (v:Vector):Void {		this.x -= v.x;		this.y -= v.y;	}		public function minusNew(v:Vector):Vector {		return new Vector(this.x - v.x, this.y - v.y);	}		// Change DIRECTION of the vector	public function negate ():Void {		this.x = - this.x;		this.y = - this.y;	}		public function negateNew ():Vector {		return new Vector (-this.x, -this.y);	}			// Change LENGTH of vector	public function scale (s:Number):Void {		this.x *= s;		this.y *= s;	}		public function scale_x(s:Number):Void {		this.x *= s;	}		public function scale_y(s:Number):Void {		this.y *= s;	}		public function scaleNew (s:Number):Vector {		return new Vector (this.x *= s, this.y *= s);	}		// Handle LENGTH (size) of the vector	public function getLength():Number {		return Math.sqrt (this.x*this.x + this.y*this.y);	}		public function setLength(len):Void {		var r = getLength();		if (r){			scale(len/r);		} else {			this.x = len;		}	}		public function growLengthNew (len:Number, angle:Number):Vector {		var ny = len * getSinD(angle);		var nx = len * getCosD(angle);		return new Vector (nx, ny);	}		// handle the vector ANGLE	public function getAngle():Number {		return getAtan2D (this.y, this.x);	}		public function setAngle(angle:Number):Void {		var r = getLength();		this.x = r * getCosD(angle);		this.y = r * getSinD(angle);	}		// ROTATE the vector		public function rotate(angle:Number):Void {		var ca = getCosD(angle);		var sa = getSinD(angle);			var rx = x * ca - y * sa;		var ry = x * sa + y * ca;		x = rx;		y = ry;	}		public function rotateNew(angle:Number) {		var v = new Vector(x, y);		v.rotate(angle);	}		// DOT PRODUCT	// Dot product gives information about relationship betweeen	// two vectors.		public function getDot(v:Vector):Number {		return (x * v.x + y * v.y);	}		// returns a perpendicular vector	public function getNormal ():Vector {		return new Vector(-y, x);	}		public function checkIfPerpTo (v:Vector):Boolean {		return getDot(v) == 0;	}		public function getAngleBetween (v:Vector):Number {		var dp = getDot(v);		var cosAngle = dp / (this.getLength() * v.getLength());		return getAcosD(cosAngle);	}		public function getSlopeTo (v:Vector):Number {		return (y - v.y) / (x - v.x);	}		public function getAvg (v:Vector):Vector {		var ax = (x + v.x)/2;		var ay = (y + v.y)/2;		return new Vector (ax, ay);	}		// MATH functions	// should probably be done as an interface that gets implemented by Vector	public function getAtan2D(y:Number, x:Number):Number {		return Math.atan2 (y, x) *  (180 / Math.PI);	}	 	// returns an angle in degrees	public function getCosD(angle:Number):Number {		return Math.cos (angle * (Math.PI / 180));	}			public function getSinD(angle:Number):Number {		return Math.sin (angle * (Math.PI / 180));	}		// acos takes a ratio between -1 and 1 and returns an angle in radians	// acosD returns angle in degrees instead.	public function getAcosD(ratio:Number):Number {		return Math.acos(ratio) * (180 / Math.PI);	}}