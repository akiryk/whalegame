import mx.transitions.Tween;import com.robertpenner.easing.*;import AsBroadcaster;class Smurfy {		// PROPERTIES	private var target_mc:MovieClip;	private var smurfy_mc:MovieClip;	private var parachute_mc:MovieClip;	private var pos:Vector;	private var vel:Vector;	private var accel:Vector;	private var rot:Number;	private var func:Function;	private var friction:Number;		private var sm_listeners:Array;	private var myListener:Object;		// properties for sine wave function	private var t:Number;	private var amp:Number;	private var period:Number;	private var timeshift:Number;	private var offset:Number;				private var isFree:Boolean;	private var slingshot:SlingShot;	private var intervalID:Number;	private var rTween:Object;	private var depth:Number;	private var poking:Boolean;		// STATIC PROPERTIES i.e. properties of the class, NOT of instances	private static var seaLevel:Number // determines when Smurfy hits water and where he floats	// LISTENER PROP	private var events:Object;		// CONSTRUCTOR	public function Smurfy (target:MovieClip, depth:Number, v:Vector, s:SlingShot) {		events = new Object();		AsBroadcaster.initialize(events); 				slingshot = s;		poking = false;		seaLevel = 98; // i.e. 120 below start location		target_mc = target;		this.depth = depth;		attachParachute();		smurfy_mc = target_mc.attachMovie("smurf", "smurf" + this.depth, this.depth);		smurfy_mc.obj = this;				pos = v.getClone();		updateCoords(v);		setFriction(0.95);		sm_listeners = new Array();				addKeyListener(this);		isFree = false;	}		// UPDATER FUNCTIONS	private function setUpdateFunction(f:Function):Void {		func = f;	}		private function update():Void {		this.func();	}		/*	***********************	Using Mover Class	Create a new Mover object for each  phase of motion	1. First Mover object is for going up;	2. Second is for falling with parachute	3. Third is for being in water	************************	*/		// *** TRAVELLING THROUGH THE AIR	private function updateInAir():Void {		var goingUp:Boolean = false;		if (vel.getY() < 0){			goingUp = true;		}				vel.plus(accel);		// Find the moment when smurfy starts falling		// if smurfy is above the given height (below 100), set chute to open		if (goingUp && vel.getY() >= 0 && pos.getY() <  -100){			setUpdateFunction(updateInChute);			intervalID = setInterval(openChute, 300, this);		}				applyFriction();		checkXBoundaries();		checkYBoundary();				pos.plus(vel);				changePosition();		changeRotation();	}		// *** TRAVELLING IN PARACHUTE	private function updateInChute():Void {		vel.plus(accel);		applyFriction();		checkXBoundaries();		checkYBoundary();		pos.plus(vel);		changePosition();	}		/*	********	SINKING IN WATER	*******	*/	private function updateSinking():Void {		vel.plus(accel);		pos.plus(vel);		pos.updateCoords(pos.getX(), pos.getY());		smurfy_mc._x = parachute_mc._x = pos.getX();		smurfy_mc._y = parachute_mc._y = pos.getY();		if (smurfy_mc._y > 840){			smurfy_mc.removeMovieClip();			events.broadcastMessage("onSmurfySunk", this);		}	}		/*	********	LANDING IN WATER	*******	*/	private function updateInWater():Void {		checkRotation();		var newY = getWaterY() + seaLevel; 		// 70 represents the offset needed for smurfy to rise to surface or water		// a higher number would mean smurfy stays underwater		// a lower number means it rises higher up				vel.plus(accel);		applyFriction();		pos.plus(vel);		pos.updateCoords(pos.getX(), newY);		smurfy_mc._x = parachute_mc._x = pos.getX();		smurfy_mc._y = parachute_mc._y = pos.getY();		smurfy_mc._rotation += rot;				if (t == Math.ceil(0.75 * period)) {			// surface of water			amp *= .4; // determines how much faller slows down with each re-surfacing			offset =  amp;		}		if (t == Math.ceil(0.25 * period)) { 			period = Math.ceil(period * 0.88);		}		if (t == Math.ceil(period)) {			t = 0;		} else {			t++;		}		if (amp < 4) {			///* do this to  have smurfy sink			vel.updateCoords(vel.getX(), 2);			accel.updateCoords(accel.getX(), 2);			setUpdateFunction(updateSinking);			//*/			//reset();			//slingshot.placeSmurfy();		}	}		// water wave function	private function getWaterY(){ //t, amp, period, timeshift, offset		var y = amp * Math.sin((t - timeshift) * (2 * Math.PI) / period) + offset;		return y;	}	/*******************	BROADCAST/LISTEN FUNCTIONS	********************/	public function addListener(listener:Object){		events.addListener(listener);	}		public function removeListener(listener:Object){		events.removeListener(listener);	}		private function addKeyListener(o:Object):Void {		myListener = new Object();		myListener.onKeyDown = function () {			if (Key.getCode() == Key.RIGHT && o.poking == false && o.isFree == true) { // && o.poking == false){				o.togglePoking();				o.smurfy_mc.gotoAndPlay(2);				o.events.broadcastMessage("onPoke", o.smurfy_mc);			}			if (Key.getCode() == Key.LEFT && o.poking == false && o.isFree == true) { // && o.poking == false){				o.togglePoking();				o.smurfy_mc.gotoAndPlay(10);				o.events.broadcastMessage("onPoke", o.smurfy_mc);			}		}				myListener.onKeyUp = function () {			o.togglePoking();		}				Key.addListener(myListener);	}		private function removeKeyListener():Void {		Key.removeListener(myListener);	}    public function togglePoking():Void {	  if (poking) {		  poking = false;	  } else {		  poking = true;	  }  }	  		/*	*********	CHECK BOUNDARIES	*********	*/		private function checkYBoundary():Void {		// CHECK FOR WHEN SMURFY HITS WATER		// CHECK FOR WHEN SMURFY STARTS FALLING		if (smurfy_mc._y > seaLevel && vel.getY() > 0) {			t = 0;			if ( vel.getY() > 20){				amp = 80;//100;			} else if ( vel.getY() > 14){				amp = Math.ceil(3 * vel.getY()) + 15;//100;			} else {				amp = Math.ceil(3 * vel.getY()) + 10;//100;			}			period = 24;			timeshift = 0;			offset = amp;			removeParachute();			setFriction(0.9);			setUpdateFunction (updateInWater);			events.broadcastMessage("onSmurfyInWater");			removeKeyListener(myListener);		}			}		private function checkXBoundaries():Void {		// purpose of this function is to keep smurfy from going off the sides of screen		if (pos.getX() > 1100 && vel.getX() > 0){			// if smurf is going right and is over the line, create some wind going in the other direction			setFriction(0.8);		}	}			/*	*********	GET/SET PROPERTIES	*********	*/		public function reset():Void {		turnOffEnterFrame();		turnOffrTween();		removeParachute();		setFriction(0.95);	}		public function updateCoords(v:Vector):Void {		pos.updateCoords(v.getX(), v.getY());		var angle = v.getAngle();		smurfy_mc._x = pos.getX();		smurfy_mc._y = pos.getY();		smurfy_mc._rotation = angle - 90;	}			public function setFree ():Void {		isFree = true;		setVelocity();				if (vel.getX() > 0){			//movingRight = true;			rot = 4;		} else {			//movingRight = false;			rot = -4;		}		setUpdateFunction(updateInAir);		turnOnEnterFrame();	}		public function getIsFree():Boolean {		return isFree;	}		private function turnOffEnterFrame():Void {		delete smurfy_mc.onEnterFrame;	}		private function turnOnEnterFrame():Void {		smurfy_mc.onEnterFrame = function(){			// start calling update()			this.obj.update(); 		}	}		private function turnOffrTween():Void {		rTween.fforward();		delete rTween;	}		private function removeParachute():Void{		parachute_mc.gotoAndPlay("out");	}	private function attachParachute():Void {		parachute_mc = target_mc.attachMovie("parachute", "parachute" + depth, depth);				parachute_mc._rotation = 0;		parachute_mc._visible = false;		depth++;	}		private function setFriction(f:Number):Void {		friction = f;	}			private function applyFriction():Void {		var ax = vel.getX() * friction;		var ay = vel.getY();		vel.updateCoords(ax, ay);	}		private function changePosition():Void {		smurfy_mc._x = parachute_mc._x = pos.getX();		smurfy_mc._y = parachute_mc._y = pos.getY();	}		public function setVelocity():Void {		vel = pos.getClone();		vel.scale(0.6);		vel.negate();		accel = new Vector(0, 4);			}	private function changeRotation():Void{		var r:Number = smurfy_mc._rotation + 180;		smurfy_mc._rotation += rot;	}		private function checkRotation():Void {		// stop rotation once smurfy is straight.		var r:Number = smurfy_mc._rotation + 180;		//if (vel.getX() >= 0 && smurfy_mc._rotation < 0){		if (r < 181 && r > 179){			rot = 0;			smurfy_mc._rotation = 0;		} /*else if (vel.getX() <= 0 && smurfy_mc._rotation > 0){			rot = 0;			smurfy_mc._rotation = 0;		} */	}			private function openChute(o):Void {		clearInterval(o.intervalID);		o.parachute_mc._visible = true;		o.parachute_mc.gotoAndPlay(1);		o.vel.updateCoords(o.vel.getX(), 0);		o.accel.updateCoords(0,0.2);		//o.rot *= -1;		o.rTween = new Tween(o.smurfy_mc, "_rotation", Elastic.easeOut, o.smurfy_mc._rotation, 0, 100, false); //obj, prop, func, begin, finish, duration, useSeconds	}			public function killSmurfy():Void {		turnOffrTween();		turnOffEnterFrame();		clearInterval(intervalID);		removeParachute();				// get rid of key listener		removeKeyListener();		delete myListener;	}				}